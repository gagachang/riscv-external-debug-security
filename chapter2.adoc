[[Sdsec]]
== Sdsec (ISA extension)

This chapter introduces the Sdsec ISA extension, which extends the Sdext of _The RISC-V Debug Specification_ cite:[dbgspec]. The RISC-V hart must implement all features in this chapter to ensure external debug security. The Sdsec extension imposes RISC-V privilege level based protection on debug operations and trigger behaviors cite:[dbgspec]. Additionally, it constrains trace functionality cite:[etrace] according to RISC-V privilege levels. 

The Sdsec extension exclusively defines the machine mode external debug security control. The Smsdedbg and Smsdetrc extensions cite:[smmtt] comprise the security control for the supervisor domain, expanded by the Sdsec extension with additional details.  

[[sdsecextdbg]]
=== External Debug

Chapter 3 of _The RISC-V Debug Specification_ lists all mandatory and optional debug operations. The operations listed below are affected by Sdsec extension. Within the context of this chapter, *debug operations* refer specifically to those listed, while other operations are excluded.
	
[[dbops]]
.Debug operations affected by Sdsec extension
* Halting the hart to entering debug mode
* Executing Program buffer                                                
* Serving abstract commands (Access Register, Quick Access, Access Memory)

When the external debug are disallowed in the RISC-V privilege level, the RISC-V hart running in the privilege level behaves as the following: 

[[dbgdisallowed]]
.Behaviors of hart when debug disallowed
* Halt request (haltreq), single step into disallowed privilege or halt group that cause hart to enter debug mode will be pending  
* Trigger (with action=1) will not match or fire 
* Abstract commands without halting (register access and quick access) will be dropped and set `cmderr` to 6 

The subsequent subsections explains how external debug are granted by <<mdbgctl, machine mode debug control>> and/or <<submdbgctl, supervisor domain debug control>> with respect to hart privilege level. 

[NOTE]
A pending request to enter debug mode can dynamically change from a disallowed state to an allowed state due to updates in debug controls. For example, once the software completes executing confidential code, it can grant debuggability for an external debugger. Afterwards , the software can enter a while(1) loop, waiting for the debugger to take control and break out of the loop.

[[mdbgctl]]
==== Machine Mode Debug Control

An input port, named mdbgen[i], is introduced to control the debuggability of machine mode for each hart i. This signal is propagated to the hart i and Debug Module. When mdbgen[i] is set to 1, the following rules apply:


- The <<dbgaccpriv, debug access privilege>> for the hart can be configured to any privilege level 
- The <<dbops, debug operations>> are permitted when hart i executes in all modes. 
- If register access without halting the hart is supported, this access carries the privilege of machine mode.

when mdbgen[i] is set to 0, the <<dbops, debug operations>> are disallowed and the <<dbgdisallowed, behaviros>> applies when the hart runs in machine mode. 

[NOTE]
For a homogeneous computing system, the implementation can consolidate all mdbgen[i] into a single port to enforce unified debug policy across all harts.

[[submdbgctl]]
==== Supervisor Domain Debug Control
The Smsdedbg extension introduces `sdedbgalw` field in CSR <<Sdseccsr,msdcfg>> to control debuggability of supervisor domains cite:[smmtt]. The `sdedbgalw` along with mdbgen[i] determines the debug allowed privilege levels, as illustrated in <<dbgpriv>>. The <<dbgaccpriv, debug access privilege>> can only be configured to debug allowed levels. It is implementation-specific whether to retain a legal value or trigger a security fault error (cmderr 6) when the <<dbgaccpriv, debug access privilege>> is set to a disallowed privilege level. 

[[dbgpriv]]
[options="header"]
[cols="25%,25%,50%"]
.External debug allowed privilege levels per debug controls 
|============================================
| mdbgen[i] | sdedbgalw | Debug allowed privilege levels 
| 1      | x      | All                      
| 0      | 1      | All except M             
| 0      | 0      | None                      
|============================================

The <<dbops, debug operations>> are allowed when hart i executes in the supervisor domain only if the logical-OR of values in `sdedbgalw` and mdbgen[i] is 1. Otherwise, the <<dbops, debug operations>> and the hart follows the <<dbgdisallowed, behaviros>> in all modes.

If register access without halting is supported, this access bears the privilege of supervisor mode to access the hart when mdbgen[i] is 0 and `sdedbgalw` is 1.

[[dbgaccpriv]]
==== Debug Access Privilege

The *debug access privilege* is defined as the privilege with which abstract commands or instructions in program buffers access hardware resources such as registers and memory. This privilege operates independently of hart privilege levels and exclusively affects operations within Debug Mode. Memory and register access within Debug Mode are subject to the *debug access privilege*, with all hardware protections, including MMU, PMP, and PMA, checked against it. This privilege is represented by the `prv` and `v` fields in `dcsr`. The permissible privilege levels programmable to `dcsr` in Debug Mode are elaborated in subsequent sections.

In addition, the `mprv` and `mpp` fields take effect exclusively when the *debug access privilege* is machine mode.

[[prvvacc]]
===== Configuring dcsr for External Debugger Access Privileges

The `prv` and `v` fields in the dcsr (at 0x7b0) have been modified to authorize privilege for external debug accesses. Upon transitioning into Debug Mode, the `prv` and `v` fields are updated to the privilege level the hart was previously operating in. The dcsr is always accessible in Debug Mode, and the fields `prv` and `v` are configurable. The maximum debug privilege level that can be configured in `prv` and `v` is determined in <<maxdbgpriv>>. It is an implementation choice whether to retain a legal value or trigger a security fault error (cmderr 6) when the `prv` and `v` are configured with an illegal privilege level. Illegal privilege levels include unsupported levels and any level higher than the maximum allowed debug privilege.

[[maxdbgpriv]]
[options="header"]
.Determining maximum debug access privilege with mdbgen[i] and sdedbgalw
|=========================================
| mdbgen[i] | sdedbgalw | Maximum debug privilege allowed 
| 1      | x      | M                 
| 0      | 1      | S(HS)             
| 0      | 0      | None               
|=========================================

[NOTE]
As the `prv` and `v` fields in dcsr are Write Any Read Legal (WARL) fields, the debugger has two options to confirm the success of a prior write: either by reading back the attempted written value or by checking the `cmderr`, depending on the hardware implementation choice. The external debugger is able to read back the written value to determine the maximum debug privilege level.  

Memory and CSR accesses initiated by abstract commands or from the program buffer will be treated as if they are at the privilege level held in `prv` and `v`. These accesses will undergo protections of PMA, PMP, MMU, and other mechanisms, and triggers traps if they violate corresponding rules. 
 
==== Privilege Level Changing Instructions

The RISC-V Debug Specification defines that the instructions that change the privilege mode have UNSPECIFIED behavior when executed within the Program Buffer, with exception of the ebreak instruction. In Sdsec, those instructions including mret, sret, uret, ecall, must either act as NOP or trigger an exception (stopping execution and setting `cmderr` to 3) in Program Buffer. Notably, these instructions retain their normal functionality during single stepping.

=== Trace
When Sdsec is supported, the optional sideband signal to trace encoder, sec_check[i] cite:[etrace], must be implemented for each hart i, and this signal must be reset to 1. The sec_check[i] signal is only cleared when trace is allowed by <<mtrcctl, machine mode trace control>> and/or <<sdtrcctl, supervisor domain trace control>>.

[mtrcctl]
==== Machine Mode Trace Control 
For each hart i, an input port, mtrcen[i], controls machine mode trace availability. Setting mtrcen[i] to 1 enables machine mode and supervisor domain trace by clearing the sec_check[i] signal to 0 across all privilege levels. Conversely, if mtrcen[i] is set to 0, the sec_check[i] signal cannot be cleared when the hart runs in machine mode.

[NOTE]
For a homogeneous computing system, similarly to machine mode debug control, the implementation can consolidate all mtrcen[i] into a single port to constrain trace capability across all harts.

[sdtrcctl]
==== Supervisor Domain Trace Control 
The Smsdetrc extension introduces `sdetrcalw` field in CSR <<Sdseccsr,msdcfg>> within hart i. The sec_check[i] signal for hart i in supervisor domain is determined by the `sdetrcalw` field and mtrcen[i]. When the logical-OR of `sdetrcalw` and mtrcen[i] is 1, the sec_check[i] signal is cleared while the hart runs in supervisor domain.

When both `sdetrcalw` and mtrcen[i] are set to 0, the sec_check[i] signal cannot be cleared at all.

[[trcctl]]
[options="header"]
.Status of the sec_check[i] sideband signal across privilege levels
|===========================================================
| mtrcen| sdetrcalw| Machine mode | Supervisor domain
| 1     | x     | sec_check[i] = 0   | sec_check[i] = 0     
| 0     | 1     | sec_check[i] = 1   | sec_check[i] = 0     
| 0     | 0     | sec_check[i] = 1   | sec_check[i] = 1     
|===========================================================

[NOTE]

The sec_check signal serves as an additional signal for the trace module, indicating that trace output is prohibited due to security controls. Functionally, sec_check behaves identically to the halted signal. Both sec_check and halted signals cannot be active simultaneously. Reserved for future applications, the combined state of [sec_check, halted] as 0b11 remains unutilized. In cases where a trace module lacks support for the sec_check signal, the hart may alternatively toggle the halted signal to restrict trace output.

=== Trigger (Sdtrig)

The trigger configured to enter Debug Mode is checked by Sdsec extension. The trigger can fire or match in privilege modes when external debug is allowed, as outlined in <<dbgpriv>>. 

The extension requires that all pending triggers intending to enter Debug Mode must match or fire before any hart mode switch to prevent privilege escalation.

==== Machine mode accessibility to `dmode` accessibility
 
The RISC-V Debug Specification defines that the `dmode` field is accessible only in Debug Mode. When this field is set, the trigger is allocated exclusively to Debug Mode, and any write access from the hart are disregarded. The Sdsec extension relaxes the constraint to the `dmode`, allowing it to be R/W in machine mode when mdbgen[i] is set to 0. When mdbgen[i] is set to 1, it remains exclusively accessible within Debug Mode.

[NOTE]
 The Debug Mode exclusive trigger could potentially serve as an attack surface for unauthorized supervisor domains where debugging is forbidden. With Sdsec extension, machine mode software assumes responsibility for switching the trigger context according to the debug policy enforced for the supervisor domain. As a result, it maintains a clean trigger context for the supervisor domain.

==== External triggers

The external trigger outputs follow the same limitations as other triggers, ensuring they do not fire or match when the privilege level of the hart exceeds the ones specified in <<dbgpriv>>.

The sources of external trigger input (such as machine mode performance counter overflow, interrupts, etc.) require protection to prevent information leakage. The external trigger inputs supported are platform-specific. Therefore, the platform is responsible for enforcing limitations on input sources. As a result, tmexttrigger.intctl and tmexttrigger.select should be restricted to legal values based on mdbgen[i] and `sdedbgalw`. Their definitions are provided in the <<redtmext>> below.

==== Trigger chain

The privilege level of the trigger chain is determined by the highest privilege level within the chain. The entire trigger chain cannot be modified if the chain privilege level exceeds the <<dbgaccpriv, debug access privilege>>.

[NOTE]
This represents a balance between usability and hardware complexity. The integrity of the trigger chain set by the hart must be maintained when an external debugger intends to utilize triggers. There may be instances where the triggers are linked across different privilege levels (e.g., from supervisor mode to machine mode), while the external debugger may only have access to supervisor mode privilege. The external debugger should not alter the chain, because it could suppress or incorrectly raise breakpoint exceptions in machine mode.

==== Sdtrig CSR

The extension enforces access control in Debug Mode, which complicates trigger usage within Debug Mode. To mitigate these complications, certain trigger CSRs, tselect, tdata1, tdata2, tdata3, and tinfo are always permitted in Debug Mode, irrespective of the privileges granted to external debuggers. However, the remaining CSRs, tcontrol, scontext, hcontext, mcontext, and mscontext continue to adhere to the granted debug access privilege.

[options="header"]
[cols="20%,20%,60%"]
.Trigger CSR accessibility in Debug Mode
|================================================================
| Register         | without Sdsec | with Sdsec                      
| tselect(0x7a0)   | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata1(0x7a1)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata2(0x7a2)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata3(0x7a3)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tinfo(0x7a4)     | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tcontrol(0x7a5)  | Always     | mdbgen[i] == 1   
| scontext(0x5a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| hcontext(0x6a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| mcontext(0x7a8)  | Always     | mdbgen[i] == 1 
| mscontext(0x7aa) | Always     | mdbgen[i] == 1     
|================================================================

Beyond CSR level accessibility adjustments, the fields within mcontrol, mcontrol6, icount, itrigger, etrigger, and tmexttrigger (variants of tdata1 located at 0x7a1) are redefined to limit the effective scope of triggers as follows.

[options="header"]
[cols="40%,60%"]
.Tdata1 fields accessibility against privilege granted to external debugger
|====================================
| Field | Accessibility
| m     | mdbgen[i] == 1                           
| s     | mdbgen[i] == 1 \|\| sdedbgalw == 1    
| u     | mdbgen[i] == 1 \|\| sdedbgalw == 1   
| vs    | mdbgen[i] == 1 \|\| sdedbgalw == 1  
| vu    | mdbgen[i] == 1 \|\| sdedbgalw == 1
|====================================

The `intctl` and `sselect` field within tmexttrigger are redifined as follows. 

[[redtmext]]
.Redefinition of field `intctl` and `sselect` within tmexttrigger
[options="header"]
[cols="10%,70%,10%,10%"]
|========================================================================================================================================================================================================================================================================
| Field  | Description                                                                                                                                                                                                                                 | Access  | Reset 
| intctl | This optional bit, when set, causes this trigger to fire whenever an attached interrupt controller signals a trigger.  the field is only configurable when mdbgen[i] is set to 1. | WLRL    | 0     
| sselect | Selects any combination of up to 16 Trigger Module external trigger inputs that cause this trigger to fire The legal value must be constrained by mdbgen[i] and `sdedbgalw` according to trigger input type.                                         | WLRL    | 0     
|========================================================================================================================================================================================================================================================================

=== Other CSR updates

==== Debug Control and Status (dcsr)

The access rule for field `prv` and `v` are addressed in subsection <<prvvacc>>. Beside `prv` and `v`, the fields in dcsr are further constrained based on their sphere of action. When a field is effective in machine mode, it is accessible only to debugger which is granted with machine mode privilege. The detailed accessibility is listed in the following table.

.Dcsr fields accessibility against privilege granted to external debugger
[options="header"]
[cols="40%,60%"]
|============================================
| Field    |  Accessibility
| ebreakvs |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakvu |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakm  |  mdbgen[i] == 1
| ebreaks  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreaku  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| stepie   |  mdbgen[i] == 1
| stoptime |  mdbgen[i] == 1
| mprven   |  mdbgen[i] == 1
| nmip     |  mdbgen[i] == 1
|============================================

==== Debug PC (dpc) and Debug Scratch Register (dscratch0 and dscratch1)

Debug PC (at 0x7b1) and Debug Scratch Register (at 0x7b2 and 0x7b3) are not restricted by <<dbgaccpriv, debug access privilege>> and are always accesible in debug mode.

[[Sdseccsr]]
==== Sdsec CSR

The Sdsec extension does not introduce any new CSR. The CSR control knobs in `msdcfg` for supervisor domain debug and trace are specified in Smsdedbg and Smsdetrc extension respectively in _RISC-V Supervisor Domains Access Protection_ cite:[smmtt]. The Smsdedbg and/or Smsdetrc extension must be implemented to support security control for debugging and/or tracing in supervisor domain.

