[[Sdsec]]
== Sdsec (ISA extension)

This chapter introduces Sdsec ISA extension, which enhances the Sdext of _The RISC-V Debug Specification_ cite:[dbgspec]. The Sdsec extension provides privilege based protection for debug operations and trigger behaviors cite:[dbgspec]. furthermore, it constrains trace functionality cite:[etrace] according to RISC-V privilege levels. 

[[sdsecextdbg]]
=== External Debug

Chapter 3 of _The RISC-V Debug Specification_ cite:[dbgspec] outlines all mandatory and optional debug operations. The operations listed below are affected by the Sdsec extension. In the context of this chapter, *debug operations* refer exclusively to those listed, and other operations remain unaffected by this specification.

[[dbops]]
.Debug operations affected by Sdsec extension
* Halting the hart to enter debug mode
* Executing Program buffer                                                
* Serving abstract commands (Access Register, Quick Access, Access Memory)

When the external debug is disallowed in running privilege level, the hart behaves as the following: 

[[dbgdisallowed]]
* The hart will not enter debug mode on halt request (haltreq), single step or halt group. Halt request will be pending until debug is allowed again  
* Triggers (with action=1) will not match or fire 
* Abstract commands without halting (register access and quick access) will be dropped and set `cmderr` to 6 

The subsequent subsections describe how external debug is authorized by <<mdbgctl, machine mode debug control>> and <<submdbgctl, supervisor domain debug control>>.

[NOTE]
A pending request to enter debug mode can dynamically change from a disallowed state to an allowed state due to updates in debug controls. For example, once the software completes executing confidential code, it can grant debuggability for an external debugger. Afterwards, the software can enter a while(1) loop, waiting for the debugger to take control and break out of the loop.

[[mdbgctl]]
==== Machine Mode Debug Control
//The control logic is inside DM or hart?
//Refer to the figure for implementation to help ppl understand why propagated to hart and debug module
//Add a section to explain the port should be controlled by root-of-trust
An input port mdbgen[i] is introduced to control the debuggability of machine mode for each hart i. This signal is propagated to every hart and Debug Module. When mdbgen[i] is set to 1, the following rules apply: 

- The <<dbgaccpriv, debug access privilege>> for the hart can be configured to any privilege level 
- The <<dbops, debug operations>> are permitted when hart i executes in all modes. 
- If register access without halting the hart is supported, this access carries the privilege of machine mode.

When mdbgen[i] is set to 0, the <<dbops, debug operations>> are disallowed and the <<dbgdisallowed, behaviros>> applies when the hart runs in machine mode. 

[NOTE]
For a homogeneous computing system, the implementation can consolidate all mdbgen[i] into a single port to enforce a unified debug policy across all harts.

[[submdbgctl]]
==== Supervisor Domain Debug Control
The Smsdedbg extension introduces `sdedbgalw` field in CSR <<Sdseccsr,msdcfg>> to control debuggability of supervisor domains cite:[smmtt]. The `sdedbgalw` along with mdbgen[i] determines the debug allowed privilege levels, as illustrated in <<dbgpriv>>. The <<dbgaccpriv, debug access privilege>> can only be configured to debug allowed levels. It is implementation-specific whether to retain a legal value or trigger a security fault error (cmderr 6) when the <<dbgaccpriv, debug access privilege>> is set to a disallowed privilege level. 

[[dbgpriv]]
[options="header"]
[cols="25%,25%,50%"]
.External debug allowed privilege levels per debug controls 
|============================================
| mdbgen[i] | sdedbgalw | Debug allowed privilege levels 
| 1      | Don't care      | All                      
| 0      | 1      | All except M             
| 0      | 0      | None                      
|============================================

The <<dbops, debug operations>> are allowed when hart i executes in the supervisor domain only if the logical-OR of values in `sdedbgalw` and mdbgen[i] is 1. Otherwise, the <<dbops, debug operations>> and the hart follows the <<dbgdisallowed, behaviros>> in all modes.

If register access without halting is supported, this access bears the privilege of supervisor mode to access the hart when mdbgen[i] is 0 and `sdedbgalw` is 1.

[[dbgaccpriv]]
==== Debug Access Privilege

The *debug access privilege* is defined as the privilege with which abstract commands or instructions in program buffers access hardware resources such as registers and memory. This privilege operates independently of hart privilege levels and exclusively affects operations within Debug Mode. Memory and register access within Debug Mode are subject to the *debug access privilege*, with all hardware protections, including MMU, PMP, and PMA, checked against it. This privilege is represented by the `prv` and `v` fields in `dcsr`. The permissible privilege levels programmable to `dcsr` in Debug Mode are elaborated in subsequent sections.

In addition, the `mprv` and `mpp` fields take effect exclusively when the *debug access privilege* is machine mode.

[[prvvacc]]
===== Configuring dcsr for External Debugger Access Privileges

The `prv` and `v` fields in the dcsr CSR have been modified to authorize privilege for external debug accesses. Upon transitioning into Debug Mode, hardware updates `prv` and `v` to the privilege level that the hart is currently running. The external debugger can still configure `prv` and `v`, however, the maximum debug privilege level that can be configured in `prv` and `v` is determined in <<maxdbgpriv>>. It is an implementation choice whether to ignore or raise a security fault error (cmderr 6) when the `prv` and `v` are configured to an illegal value. Illegal privilege levels include unsupported levels and any level higher than the maximum allowed debug privilege.

//If DCSR is WARL then should not raise error?

[[maxdbgpriv]]
[options="header"]
.Determining maximum debug access privilege with mdbgen[i] and sdedbgalw
|=========================================
| mdbgen[i] | sdedbgalw | Maximum debug privilege allowed 
| 1      | x      | M                 
| 0      | 1      | S(HS)             
| 0      | 0      | None               
|=========================================

[NOTE]
As the `prv` and `v` fields in dcsr are Write Any Read Legal (WARL) fields, the debugger has two options to confirm the success of a prior write: either by reading back the attempted written value or by checking the `cmderr`, depending on the hardware implementation choice. The external debugger is able to read back the written value to determine the maximum debug privilege level.  

Memory and CSR accesses initiated by abstract commands or from the program buffer will be treated as if they are at the privilege level held in `prv` and `v`. These accesses will undergo protections of PMA, PMP, MMU, and other mechanisms, and triggers traps if they violate corresponding rules. 
 
==== Privilege Level Changing Instructions

The RISC-V Debug Specification cite:[dbgspec] defines that the instructions that change the privilege mode have UNSPECIFIED behavior when executed within the Program Buffer, with exception of the ebreak instruction. In Sdsec, those instructions including mret, sret, uret, ecall, must either act as NOP or trigger an exception (stopping execution and setting `cmderr` to 3) in Program Buffer. Notably, these instructions retain their normal functionality during single stepping.

=== Trace
When Sdsec is supported, the optional sideband signal to trace encoder, sec_check[i] cite:[etrace], must be implemented for each hart i, and this signal must be reset to 1 (disabled). The sec_check[i] signal is only cleared when trace is allowed by <<mtrcctl, machine mode trace control>> and/or <<sdtrcctl, supervisor domain trace control>>.

[mtrcctl]
==== Machine Mode Trace Control 
For each hart i, an input port, mtrcen[i], controls machine mode trace availability. Setting mtrcen[i] to 1 enables machine mode and supervisor domain trace by clearing the sec_check[i] signal to 0 across all privilege levels. Conversely, if mtrcen[i] is set to 0, the sec_check[i] signal cannot be cleared when the hart runs in machine mode.

[NOTE]
For a homogeneous computing system, similarly to machine mode debug control, the implementation can consolidate all mtrcen[i] into a single port to constrain trace capability across all harts.

[sdtrcctl]
==== Supervisor Domain Trace Control 
The Smsdetrc extension introduces `sdetrcalw` field in CSR <<Sdseccsr,msdcfg>> within hart i. The sec_check[i] signal for hart i in supervisor domain is determined by the `sdetrcalw` field and mtrcen[i]. When the logical-OR of `sdetrcalw` and mtrcen[i] is 1, the sec_check[i] signal is cleared while the hart runs in supervisor domain.

When both `sdetrcalw` and mtrcen[i] are set to 0, the sec_check[i] signal cannot be cleared at all.

[[trcctl]]
[options="header"]
.Status of the sec_check[i] sideband signal across privilege levels
|===========================================================
| mtrcen| sdetrcalw| Machine mode | Supervisor domain
| 1     | x     | sec_check[i] = 0   | sec_check[i] = 0     
| 0     | 1     | sec_check[i] = 1   | sec_check[i] = 0     
| 0     | 0     | sec_check[i] = 1   | sec_check[i] = 1     
|===========================================================

[NOTE]
The sec_check signal serves as an additional signal for the trace module, indicating that trace output is prohibited due to security controls. Functionally, sec_check behaves identically to the halted signal. Both sec_check and halted signals cannot be active simultaneously. Reserved for future applications, the combined state of [sec_check, halted] as 0b11 remains unutilized. In cases where a trace module lacks support for the sec_check signal, the hart may alternatively toggle the halted signal to restrict trace output.

=== Trigger (Sdtrig)

Triggers configured to enter Debug Mode can only fire or match when external debug is allowed, as outlined in <<dbgpriv>>. 

[NOTE]
Implementations shall make sure that pending triggers intending to enter Debug Mode match or fire before the privilege mode switch, thus the hart will never enter Debug Mode in higher privilege mode with debug disallowed  

==== Machine mode accessibility to `dmode` 
 
The RISC-V Debug Specification cite:[dbgspec] defines that the `dmode` field is accessible only in Debug Mode. When this field is set, the trigger is allocated exclusively to Debug Mode, and any write access from the hart is disregarded. The Sdsec extension relaxes the constraint to the `dmode`, allowing it to be R/W in machine mode when mdbgen[i] is set to 0. When mdbgen[i] is set to 1, it remains exclusively accessible within Debug Mode.
//What does this mean? What is Debug Mode exclusive trigger?
//New proposal is to add another nob to clear trigger registers

[NOTE]
The Debug Mode exclusive trigger could potentially serve as an attack surface for unauthorized supervisor domains where debugging is forbidden. With Sdsec extension, machine mode software assumes responsibility for switching the trigger context according to the debug policy enforced for the supervisor domain. As a result, it maintains a clean trigger context for the supervisor domain.

==== External triggers

The external trigger outputs will not fire or match when the privilege level of the hart exceeds the ones specified in <<dbgpriv>>.

The sources of external trigger input (such as machine mode performance counter overflow, interrupts, etc.) require protection to prevent information leakage. The external trigger inputs supported are platform-specific. Therefore, the platform is responsible for enforcing limitations on input sources. As a result, tmexttrigger.intctl and tmexttrigger.select should be restricted to legal values based on mdbgen[i] and `sdedbgalw`. Their definitions are provided in the <<redtmext>> below.

//What is the difference between input and output?
//If a hart has external trigger outputs to TM, the external trigger output signals will not be asserted if ....
//In other words, the external trigger can only fire when both source and dest are both allowed to be debugged
//If the source of external trigger is a system component then the system component is responsible of source control (out of scope for this spec)

==== Trigger chain

The privilege level of the trigger chain is determined by the highest privilege level of the chain. The entire trigger chain cannot be modified if the chain privilege level exceeds the <<dbgaccpriv, debug access privilege>>.

[NOTE]
This represents a balance between usability and hardware complexity. The integrity of the trigger chain set by the hart must be maintained when an external debugger intends to utilize triggers. There may be instances where the triggers are linked across different privilege levels (e.g., from supervisor mode to machine mode), while the external debugger may only have access to supervisor mode privilege. The external debugger should not alter the chain, because it could suppress or incorrectly raise breakpoint exceptions in machine mode.

==== Sdtrig CSR

tcontrol, scontext, hcontext, mcontext, and mscontext CSR must follow access rules defined in <<dbgaccpriv, debug access privilege>>, illustrated in below table.

[options="header"]
[cols="20%,20%,60%"]
.Trigger CSR accessibility in Debug Mode
|================================================================
| Register         | without Sdsec | with Sdsec                      
| tselect(0x7a0)   | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata1(0x7a1)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata2(0x7a2)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata3(0x7a3)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tinfo(0x7a4)     | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tcontrol(0x7a5)  | Always     | mdbgen[i] == 1   
| scontext(0x5a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| hcontext(0x6a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| mcontext(0x7a8)  | Always     | mdbgen[i] == 1 
| mscontext(0x7aa) | Always     | mdbgen[i] == 1     
|================================================================

Below fields in mcontrol, mcontrol6, icount, itrigger, etrigger, and tmexttrigger must follow <<dbgaccpriv, debug access privilege>>.

[options="header"]
[cols="40%,60%"]
.Tdata1 fields accessibility against privilege granted to external debugger
|====================================
| Field | Accessibility
| m     | mdbgen[i] == 1                           
| s     | mdbgen[i] == 1 \|\| sdedbgalw == 1    
| u     | mdbgen[i] == 1 \|\| sdedbgalw == 1   
| vs    | mdbgen[i] == 1 \|\| sdedbgalw == 1  
| vu    | mdbgen[i] == 1 \|\| sdedbgalw == 1
|====================================

The `intctl` and `sselect` fields in tmexttrigger are redifined as follows. 

[[redtmext]]
.Redefinition of field `intctl` and `sselect` within tmexttrigger
[options="header"]
[cols="10%,70%,10%,10%"]
|========================================================================================================================================================================================================================================================================
| Field  | Description                                                                                                                                                                                                                                 | Access  | Reset 
| intctl | This optional bit, when set, causes this trigger to fire whenever an attached interrupt controller signals a trigger.  the field is only configurable when mdbgen[i] is set to 1. | WLRL    | 0     
| sselect | Selects any combination of up to 16 Trigger Module external trigger inputs that cause this trigger to fire The legal value must be constrained by mdbgen[i] and `sdedbgalw` according to trigger input type.                                         | WLRL    | 0     
|========================================================================================================================================================================================================================================================================

=== Other CSR updates

==== Debug Control and Status (dcsr)

The access rule for field `prv` and `v` are addressed in subsection <<prvvacc>>. Beside `prv` and `v`, the fields in dcsr are further constrained based on their sphere of action. When a field is effective in machine mode, it is accessible only to debugger which is granted with machine mode privilege. The detailed accessibility is listed in the following table.

.Dcsr fields accessibility against privilege granted to external debugger
[options="header"]
[cols="40%,60%"]
|============================================
| Field    |  Accessibility
| ebreakvs |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakvu |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakm  |  mdbgen[i] == 1
| ebreaks  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreaku  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| stepie   |  mdbgen[i] == 1
| stoptime |  mdbgen[i] == 1
| mprven   |  mdbgen[i] == 1
| nmip     |  mdbgen[i] == 1
|============================================

==== Debug PC (dpc) and Debug Scratch Register (dscratch0 and dscratch1)

Debug PC (at 0x7b1) and Debug Scratch Register (at 0x7b2 and 0x7b3) are not restricted by <<dbgaccpriv, debug access privilege>> and are always accesible in debug mode.

[[Sdseccsr]]
==== Sdsec CSR

The Sdsec extension does not introduce any new CSR. The CSR control knobs in `msdcfg` for supervisor domain debug and trace are specified in Smsdedbg and Smsdetrc extension respectively in _RISC-V Supervisor Domains Access Protection_ cite:[smmtt]. The Smsdedbg and/or Smsdetrc extension must be implemented to support security control for debugging and/or tracing in supervisor domain.

