[[Sdsec]]
== Sdsec (ISA extension)

This chapter introduces the Sdsec ISA extension, which extends the ISA section of The RISC-V Debug Specification. The RISC-V hart must implement the features in this chapter to ensure external debug security. It is designed to enforce access control over operations initiated by the Debug Module, as well as constraints on trigger behaviors cite:[dbgspec]. Additionally, it incorporates trace functionality cite:[etrace], with its output constrained based on hart privilege levels. 

The Sdsec extension exclusively defines the machine mode external debug security control. The Smsdedbg and Smsdetrc extensions cite:[smmtt] comprise the security control for the supervisor domain, expanded by the Sdsec extension with additional details.  

=== External Debug

The debug operations listed below are affected by external debug security specification. Within this context, *debug operations* refer specifically to those listed, while other operations are excluded from this specification. Both ISA extension and non-ISA extension impact those operations. The influence of the Sdsec extension will be detailed in the following and the non-ISA extension <<dmsext>> describes the enforcement within Debug Module.
	
[[dbops]]
.The debug operations affected by external debug security specification
* Entering debug mode
* Executing Program buffer                                                
* Reset 
* Keepalive request 
* Serving abstract commands (Access Register, Quick Access, Access Memory)

The Sdsec affects the behavior of the hart when it enters debug mode, executes program buffer and services abstract commands. Specifically, when the external debug are not granted, any action to enter debug mode will be pending while abstract commands (without halting) and requests to execute program buffer will be dropped. The subsequent subsections detail how external debug are granted by <<mdbgctl, Machine Mode Debug Control>> and/or <<submdbgctl, Supervisor Domain Debug Control>>. 

[[mdbgctl]]
==== Machine Mode Debug Control

An input port, named mdbgen[i], is introduced to control the debuggability of machine mode for each hart i. This signal is transmitted to the hart and its corresponding debug access control logic. When mdbgen[i] is set to 1, the <<dbops, debug operations>> are permitted when hart i executes in machine mode. Moreover the following rules apply:

- The <<dbgaccpriv, debug access privilege>> for the hart can be configured to any privilege level 
- If register access without halting the hart is supported, this access carries the privilege of machine mode.

When mdbgen[i] is set to 0, any attempt to halt the hart and bring it into Debug Mode will remain pending, and triggers configured to enter Debug Mode will neither fire nor match in machine mode.

[NOTE]
For a homogeneous computing system, the implementation can consolidate all mdbgen[i] into a single port to enforce unified debug policy across all harts.

[[submdbgctl]]
==== Supervisor Domain Debug Control
The supervisor domain cite:[smmtt] debug of hart i is determined by both mdbgen[i] and the `sdedbgalw` field of CSR <<Sdseccsr,msdcfg>> within hart i. The <<dbops, debug operations>> are allowed when hart i executes in the supervisor domain only if the logical-OR of values in sdedbgalw and mdbgen[i] is 1.

The legal value of <<dbgaccpriv, debug access privilege>> for hart i is solely determined by `sdedbgalw` when mdbgen[i] is 0. In the event of `sdedbgalw` being 1 while mdbgen[i] is 0, the debug access privilege can be configured to privilege levels other than machine mode. Any attempt to set debug access privilege to machine mode will either result in an legal sub-machine mode privilege level or trigger a security fault error (cmderr 6).

If register access without halting the hart is supported, this access bears the privilege of supervisor/hypervisor mode to access the hart when mdbgen[i] is 0 and `sdedbgalw` is 1.

Debug operations in all modes are prohibited for hart i when the logical-OR of `sdedbgalw` and mdbgen[i] is 0. All halt requests from the Debug Module will remain pending, and triggers configured to enter debug mode will neither match nor fire. The register access without halting is dropped and sets `cmderr` to 6.

[[dbgpriv]]
[options="header"]
.Debug allowed privilege levels per debug controls 
|============================================
| mdbgen[i] | sdedbgalw | Debug allowed privilege levels 
| 1      | x      | All                      
| 0      | 1      | All except M             
| 0      | 0      | None                      
|============================================

[[dbgaccpriv]]
==== Debug Access Privilege

The *debug access privilege* is defined as the privilege with which abstract commands or instructions in program buffers access hardware resources such as registers and memory. This privilege operates independently of hart privilege levels and exclusively affects operations within Debug Mode. Memory and register access within Debug Mode are subject to the *debug access privilege*, with all hardware protections, including MMU, PMP, and PMA, checked against it. This privilege is represented by the `prv` and `v` fields in `dcsr`, and it is updated to reflect the hart privilege level upon entering Debug Mode. Each hart has a dedicated *debug access privilege* and it may vary from each other. The permissible privilege levels programmable to `dcsr` in Debug Mode are elaborated in subsequent sections.

In addition, the `mprv` and `mpp` fields take effect exclusively when the *debug access privilege* is in machine mode.

[[maxdbgpriv]]
[options="header"]
.Determining maximum debug access privilege with mdbgen[i] and sdedbgalw
|=========================================
| mdbgen[i] | sdedbgalw | Maximum debug privilege allowed 
| 1      | x      | M                 
| 0      | 1      | S(HS)             
| 0      | 0      | None               
|=========================================

===== Configuring dcsr for External Debugger Access Privileges

The `prv` and `v` fields in the dcsr (at 0x7b0) have been enhanced to authorize privilege for debugger accesses. Upon transitioning into Debug Mode, the `prv` and `v` fields are updated to reflect the privilege level the hart was previously operating in. The dcsr is always permitted to be accessed in Debug Mode and the fields `prv` and `v` could be configured to grant privilege to the debugger other than the privilege level when the harts transitioned to Debug Mode. The maximum debug privilege level that can be configured in prv and v is determined in <<maxdbgpriv>>. It will generate a security fault error (cmderr 6) if the external debugger attempts to configure `prv` and `v` with a privilege higher than the maximum debug privilege level.

[NOTE]
As the `prv` and `v` fields in dcsr are Write Any Read Legal (WARL) fields, the debugger has two options to confirm the success of a prior write: either by reading back the attempted written value or by checking the `cmderr`, depending on the hardware implementation choice. The external debugger is able to read back the written value to determine the maximum debug privilege level.  

Memory and CSR accesses initiated by abstract commands or from the program buffer will be treated as if they are at the privilege level held in `prv` and `v`. These accesses will undergo protections of PMA, PMP, MMU, and other mechanisms, triggering traps if they violate corresponding rules. 
 
==== Privilege Level Changing Instructions

The RISC-V Debug Specification defines that the instructions that change the privilege mode have UNSPECIFIED behavior when executed within the Program Buffer, with exception of the ebreak instruction. In Sdsec, those instructions such as mret, sret, uret, ecall, must either act as NOP or trigger an exception, stopping execution and setting `cmderr` to 3. Notably, these instructions retain their normal functionality during single stepping.

=== Trace
The extension requires that trace availability from each hart is constrained by default. When Sdsec is supported, the optional sideband signal to trace encoder, sec_check[i] cite:[etrace], must be implemented for each hart i, and this signal must be reset to 1. The sec_check[i] signal is only cleared when trace is permitted by machine mode trace control or supervisor domain trace control.

==== Machine Mode Trace Control 
For each hart i, an input port, mtrcen[i], controls machine mode trace availability. Setting mtrcen[i] to 1 enables machine mode and supervisor domain trace by clearing the sec_check[i] signal to 0 across all privilege levels. Conversely, if mtrcen[i] is set to 0, the sec_check[i] signal cannot be cleared when the hart operates in machine mode.

[NOTE]
For a homogeneous computing system, similarly to machine mode debug control, the implementation can consolidate all mtrcen[i] into a single port to constrain trace capability across all harts.

==== Supervisor Domain Mode Trace Control 
The sec_check[i] signal for hart i in supervisor domain is determined by the `sdetrcalw` field of CSR <<Sdseccsr, msdcfg>> within hart i, alongside mtrcen[i]. When the logical-OR of `sdetrcalw` and mtrcen[i] is 1, the sec_check[i] signal is cleared while the hart runs in supervisor domain.

When both `sdetrcalw` and mtrcen[i] are set to 0, the sec_check[i] signal cannot be cleared at all.

[[trcctl]]
[options="header"]
.Status of the sec_check[i] sideband signal across privilege levels
|===========================================================
| mtrcen| sdetrcalw| Machine mode | Supervisor domain
| 1     | x     | sec_check[i] = 0   | sec_check[i] = 0     
| 0     | 1     | sec_check[i] = 1   | sec_check[i] = 0     
| 0     | 0     | sec_check[i] = 1   | sec_check[i] = 1     
|===========================================================

[NOTE]

The sec_check signal serves as an additional signal for the trace module, indicating that trace output is prohibited due to security controls. Functionally, sec_check behaves identically to the halted signal. Both sec_check and halted signals cannot be active simultaneously. Reserved for future applications, the combined state of [sec_check, halted] as 0b11 remains unutilized. In cases where a trace module lacks support for the sec_check signal, the hart may alternatively toggle the halted signal to restrict trace output.

=== Trigger (Sdtrig)

The trigger configured to enter Debug Mode is checked by Sdsec extension. The trigger can fire or match in privilege modes outlined in <<dbgpriv>>. 

The extension requires that all pending triggers intending to enter Debug Mode must match or fire before any hart mode switch to prevent privilege escalation.

==== Machine mode accessibility to `dmode` accessibility
 
The RISC-V Debug Specification defines that the `dmode` field is accessible only in Debug Mode. When this field is set, the trigger is allocated exclusively to Debug Mode, and any write access from the hart are disregarded. However, the Debug Mode exclusive trigger could potentially serve as an attack surface for unauthorized supervisor domains where debugging is forbidden. The extension relaxes the constrain to the `dmode`, allowing it to be R/W in machine mode when mdbgen[i] is set to 0. When mdbgen[i] is set to 1, it remains exclusively accessible within Debug Mode.

[NOTE]
In this definition, machine mode software assumes responsibility for switching the trigger context according to the debug policy enforced for the supervisor domain. As a result, it maintains a clean trigger context for the supervisor domain.

==== External triggers

The external trigger outputs follow the same limitations as other triggers, ensuring they do not fire or match when the privilege level of the hart exceeds the ones specified in <<dbgpriv>>.

The sources of external trigger input (such as machine mode performance counter overflow, interrupts, etc.) require protection to prevent information leakage. The external trigger inputs supported are platform-specific. Therefore, the platform is responsible for enforcing limitations on input sources. As a result, tmexttrigger.intctl and tmexttrigger.select should be restricted to legal values based on mdbgen[i] and `sdedbgalw`. Their definitions are provided in the <<redtmext>> below.

==== Trigger chain

The privilege level of the trigger chain is determined by the highest privilege level within the chain. The entire trigger chain cannot be modified if the chain privilege level exceeds the <<dbgaccpriv, debug access privilege>>.

[NOTE]
This represents a balance between usability and hardware complexity. The integrity of the trigger chain set by the hart must be maintained when an external debugger intends to utilize triggers. There may be instances where the triggers are linked across different privilege levels (e.g., from supervisor mode to machine mode), while the external debugger may only have access to supervisor mode privilege. The external debugger should not alter the chain, because it could suppress or incorrectly raise breakpoint exceptions in machine mode.

==== Sdtrig CSR

The extension enforces access control in Debug Mode, which complicates trigger usage within Debug Mode. To mitigate these complications, certain trigger CSRs, tselect, tdata1, tdata2, tdata3, and tinfo are always permitted in Debug Mode, irrespective of the privileges granted to external debuggers. However, the remaining CSRs, tcontrol, scontext, hcontext, mcontext, and mscontext continue to adhere to the debug privileges granted.

[options="header"]
[cols="20%,20%,60%"]
.Trigger CSR accessibility in Debug Mode
|================================================================
| Register         | without Sdsec | with Sdsec                      
| tselect(0x7a0)   | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata1(0x7a1)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata2(0x7a2)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata3(0x7a3)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tinfo(0x7a4)     | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tcontrol(0x7a5)  | Always     | mdbgen[i] == 1   
| scontext(0x5a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| hcontext(0x6a8)  | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| mcontext(0x7a8)  | Always     | mdbgen[i] == 1 
| mscontext(0x7aa) | Always     | mdbgen[i] == 1     
|================================================================

Beyond CSR-level accessibility adjustments, the fields within mcontrol, mcontrol6, icount, itrigger, etrigger, and tmexttrigger—variants of tdata1 located at 0x7a1—are redefined to limit the effective scope of triggers as follows.

[options="header"]
[cols="40%,60%"]
.Tdata1 fields accessibility against privilege granted to external debugger
|====================================
| Field | Accessibility
| m     | mdbgen[i] == 1                           
| s     | mdbgen[i] == 1 \|\| sdedbgalw == 1    
| u     | mdbgen[i] == 1 \|\| sdedbgalw == 1   
| vs    | mdbgen[i] == 1 \|\| sdedbgalw == 1  
| vu    | mdbgen[i] == 1 \|\| sdedbgalw == 1
|====================================

The textra32, textra64 provides additional filtering capability for triggers. They are permitted for access in Debug Mode, as they do not affect the trigger firing/matching as it is constrained by mdbgen[i] and `sdedbgalw`.

The `intctl` and `sselect` field within tmexttrigger are redifined as follows. 

[[redtmext]]
.Redefinition of field `intctl` and `sselect` within tmexttrigger
[options="header"]
[cols="10%,70%,10%,10%"]
|========================================================================================================================================================================================================================================================================
| Field  | Description                                                                                                                                                                                                                                 | Access  | Reset 
| intctl | This optional bit, when set, causes this trigger to fire whenever an attached interrupt controller signals a trigger.  the field is only configurable when mdbgen[i] is set to 1. | WLRL    | 0     
| sselect | Selects any combination of up to 16 TM external trigger inputs that cause this trigger to fire The legal value must be constrained by mdbgen[i] and `sdedbgalw` according to trigger input type.                                         | WLRL    | 0     
|========================================================================================================================================================================================================================================================================

=== Other CSR updates

==== Debug Control and Status (dcsr)

Beside `prv` and `v`, the fields in dcsr are further constrained based on their sphere of action. For example, when a field is effective in machine mode, it is accessible only to debugger which is granted with machine mode privilege. The detailed accessibility is listed in the following table.

.Dcsr fields accessibility against privilege granted to external debugger
[options="header"]
[cols="40%,60%"]
|============================================
| Field    |  Accessibility
| ebreakvs |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakvu |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakm  |  mdbgen[i] == 1
| ebreaks  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreaku  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| stepie   |  mdbgen[i] == 1
| stoptime |  mdbgen[i] == 1
| mprven   |  mdbgen[i] == 1
| nmip     |  mdbgen[i] == 1
|============================================

==== Debug PC (dpc) and Debug Scratch Register (dscratch0 and dscratch1)

Debug PC (at 0x7b1) and Debug Scratch Register (at 0x7b2 and 0x7b3) are not restricted by prv and v fields to simplify the architecture.

[[Sdseccsr]]
==== Sdsec CSR

The Sdsec extension does not introduce any new CSR. The CSR control knobs in `msdcfg` for supervisor domain debug and trace are specified in Smsdedbg and Smsdetrc extension respectively in _RISC-V Supervisor Domains Access Protection_ cite:[smmtt]. The Smsdedbg and/or Smsdetrc extension must be implemented to activate security enforcement for debugging and/or tracing.

