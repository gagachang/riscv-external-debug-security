[[Sdsec]]
== Sdsec (ISA extension)

This chapter introduces Sdsec ISA extension, which enhances the Sdext of _The RISC-V Debug Specification_ cite:[dbgspec]. The Sdsec extension provides privilege based protection for debug operations and trigger behaviors cite:[dbgspec]. Furthermore, it constrains trace functionality cite:[etrace] according to RISC-V privilege levels. 

[[sdsecextdbg]]
=== External Debug

Chapter 3 of _The RISC-V Debug Specification_ cite:[dbgspec] outlines all mandatory and optional debug operations. The operations listed below are affected by the Sdsec extension, other operations remain unaffected. In the context of this chapter, *debug operations* refer to those listed below.

[[dbops]]
.Debug operations affected by Sdsec extension
* Halting the hart to enter Debug Mode
* Executing Program buffer                                                
* Serving abstract commands (Access Register, Quick Access, Access Memory)

When the external debug is disallowed in running privilege level, the hart behaves as the following: 

[[dbgdisallowed]]
* The hart will not enter Debug Dode on halt request (haltreq), single step or halt group. Halt request will be pending until debug is allowed again  
* Triggers (with `action`=1) will not match or fire 
* Abstract commands without halting (Access Register and Quick Access) will be dropped and set `cmderr` to 6 

The subsequent subsections describe how external debug is authorized by <<mdbgctl, M-mode debug control>> and <<submdbgctl, supervisor domain debug control>>.

[NOTE]
A pending request to enter Debug Mode can dynamically change from a disallowed state to an allowed state due to updates in debug controls. For example, once the software completes executing confidential code, it can grant debuggability for an external debugger. Afterwards, the software can enter a while(1) loop, waiting for the debugger to take control and break out of the loop.

[[mdbgctl]]
==== M-mode Debug Control

An input port, named mdbgen[i], is introduced to control the debuggability of M-mode for each hart i. This signal is propagated to the hart i and Debug Module as depicted in <<extdbg>>. When mdbgen[i] is set to 1, the following rules apply:

- The <<dbgaccpriv, debug access privilege>> for the hart can be configured to any legal privilege level
- The <<dbops, debug operations>> are permitted when hart i executes in all modes
- Register access without halting the hart carries M-mode privilege if supported

When mdbgen[i] is set to 0, the <<dbops, debug operations>> are disallowed and the <<dbgdisallowed, behaviros>> applies when the hart runs in M-mode. 

[NOTE]
For a homogeneous computing system, the implementation can consolidate all mdbgen[i] into a single port to enforce a unified debug policy across all harts.

[[submdbgctl]]
==== Supervisor Domain Debug Control
The Smsdedbg extension cite:[smmtt] introduces `sdedbgalw` field (bit 7) in CSR <<Sdseccsr,msdcfg>> to control the debuggability of supervisor domains. The `sdedbgalw` along with mdbgen[i] determines the debug allowed privilege levels, as illustrated in <<dbgpriv>>. The <<dbgaccpriv, debug access privilege>> can only be configured to debug allowed levels. 

[[dbgpriv]]
[options="header"]
[cols="25%,25%,50%"]
.External debug allowed privilege levels per debug controls 
|============================================
| mdbgen[i] | sdedbgalw | Debug allowed privilege levels 
| 1      | Don't care      | All                      
| 0      | 1      | All except M             
| 0      | 0      | None                      
|============================================

When debug is allowed in supervisor domain, <<dbops, debug operations>> are allowed when hart executes in supervisor domain. The register access without halting the hart carries supervisor mode privilege if supported.

[[dbgaccpriv]]
==== Debug Access Privilege

The *debug access privilege* is defined as the privilege level granted to the external debugger to access hardware resources with abstract commands or program buffers. Memory and register accesses from Debug Mode also carry *debug access privilege* instead of always with M-mode. The *debug access privilege* is represented by the `prv` and `v` fields in dcsr. The legal privilege levels programmable to `dcsr` in Debug Mode are elaborated in <<prvvacc>>. Debugger accesses to registers and memory will checked by permission check mechanisms against *debug access privilege*, and trigger traps if they violate corresponding rules.

[[prvvacc]]
===== Configuring dcsr for External Debugger Access Privileges

The dcsr (at 0x7b0) is always accessible in Debug Mode and the `prv` and `v` fields in the dcsr  have been modified to authorize privilege for external debug accesses. Upon transitioning into Debug Mode, the `prv` and `v` fields are updated to the privilege level the hart was previously operating in. The maximum debug privilege level that can be configured in `prv` and `v` is determined in <<maxdbgpriv>>. The fields retain legal values when the `prv` and `v` are configured with an illegal privilege level. Illegal privilege levels include unsupported levels and any level higher than the maximum allowed debug privilege. When the hart resumes from Debug Mode, the current privilege mode and virtualization mode are changed to that specified by `prv` and `v`.

[[maxdbgpriv]]
[options="header"]
.Determining maximum debug access privilege with mdbgen[i] and sdedbgalw
|=========================================
| mdbgen[i] | sdedbgalw | Maximum debug privilege allowed 
| 1      | Don't care      | M                 
| 0      | 1      | S(HS)             
| 0      | 0      | None               
|=========================================

[NOTE]
As the `prv` and `v` fields in dcsr are Write Any Read Legal (WARL) fields, the external debugger is able to read back the written value to determine the maximum debug privilege level.  
 
==== Privilege Level Changing Instructions

The RISC-V Debug Specification cite:[dbgspec] defines that the instructions that change the privilege mode have UNSPECIFIED behavior when executed within the Program Buffer, with exception of the ebreak instruction. In Sdsec, those instructions including mret, sret, uret, ecall, must either act as NOP or trigger an exception (stopping execution and setting `cmderr` to 3) in Program Buffer. Notably, these instructions retain their normal functionality during single stepping.

=== Trace
When Sdsec is supported, the optional sideband signal to trace encoder, sec_check[i] cite:[etrace], must be implemented for each hart i, and this signal must be reset to 1 (disabled). The sec_check[i] signal is only cleared when trace is allowed by <<mtrcctl, M-mode trace control>> and/or <<sdtrcctl, supervisor domain trace control>>.

[mtrcctl]
==== M-Mode Trace Control 
For each hart i, an input port, mtrcen[i], controls M-mode trace availability. Setting mtrcen[i] to 1 enables M-mode and supervisor domain trace by clearing the sec_check[i] signal to 0 across all privilege levels. Conversely, if mtrcen[i] is set to 0, the sec_check[i] signal cannot be cleared when the hart runs in M-mode.

[NOTE]
For a homogeneous computing system, similar to M-mode debug control, the implementation can consolidate all mtrcen[i] into a single port to constrain trace capability across all harts.

[sdtrcctl]
==== Supervisor Domain Trace Control 
The Smsdetrc extension introduces `sdetrcalw` field (bit 8) in CSR <<Sdseccsr,msdcfg>> within hart i. The sec_check[i] signal for hart i in supervisor domain is determined by the `sdetrcalw` field and mtrcen[i]. When the logical-OR of `sdetrcalw` and mtrcen[i] is 1, the sec_check[i] signal is cleared while the hart runs in supervisor domain.

When both `sdetrcalw` and mtrcen[i] are set to 0, the sec_check[i] signal cannot be cleared at all.

[[trcctl]]
[options="header"]
.Status of the sec_check[i] sideband signal across privilege levels
|===========================================================
| mtrcen| sdetrcalw| M-mode | Supervisor domain
| 1     | x     | sec_check[i] = 0   | sec_check[i] = 0     
| 0     | 1     | sec_check[i] = 1   | sec_check[i] = 0     
| 0     | 0     | sec_check[i] = 1   | sec_check[i] = 1     
|===========================================================

[NOTE]
The sec_check signal serves as an additional signal for the trace module, indicating that trace output is prohibited due to security controls. Functionally, sec_check behaves identically to the halted signal. Both sec_check and halted signals cannot be active simultaneously. Reserved for future applications, the combined state of [sec_check, halted] as 0b11 remains unutilized. In cases where a trace module lacks support for the sec_check signal, the hart may alternatively toggle the halted signal to restrict trace output.

=== Trigger (Sdtrig)

Triggers configured to enter Debug Mode can only fire or match when external debug is allowed, as outlined in <<dbgpriv>>. A trigger enabled for a privilege level higher than debug allowed privilege is not accessible by an external debugger. When this trigger is selected using `tselect`, it always reads as 0, and any writes to it are ignored.

[NOTE]
Implementations shall make sure that pending triggers intending to enter Debug Mode match or fire before the privilege mode switch, thus the hart will never enter Debug Mode in higher privilege mode with debug disallowed  

==== M-mode accessibility to `dmode` 
 
When Sdsec extension is implemented, `dmode` is read/write for both M-mode and Debug Mode when mdbgen[i] is 0 and remains only accessible to Debug Mode when mdbgen[i] is 1

[NOTE]
The `dmode` being read/write allows M-mode to switch trigger context. The trigger can form a side-channel to debug disallowed supervisor domains from a debug allowed supervisor domain if the trigger context is not switched. Although the trigger cannot fire or match in disallowed supervisor domain to enter Debug Mode, the malicious debugger can exploit it by setting a trigger to raise breakpoint exception (`action` = 0) when it is in debug allowed supervisor domain. If the trigger hits in debug disallowed supervisor domain, the external debugger can indirectly observe the executed PC, accessed memory address or read/write data in debug disallowed supervisor domain by the checking value in `hit0`/`hit1`. As the `dmode` is accessible when mdbgen[i] is 0, such attack can be mitigated by having M-mode firmware switch the trigger context at supervisor domain boundary.

==== External triggers

The external trigger outputs (with `action` = 8/9) will not fire or match when the privilege level of the hart exceeds debug allowed privilege as specified in <<dbgpriv>>.

The external trigger input can be driven by any input signals, e.g. the external trigger output from another hart or interrupt signals etc. The input signals cause the trigger to fires only when the hart is allowed to debug. The initiators of these signals are responsible for determining whether the signal is allowed to assert. For example, if the external trigger input of hart i is connected to external trigger output of hart j. The assertion of output signal from hart j is determined by its own allowed privilege level for debug. The output signal of hart j must not assert when debug is disallowed. Similarly, signals from other module in the system are managed by the individual module. When the module is not allowed to debug, the signal connected to external trigger input must not be asserted.

==== Trigger chain

The privilege level of the trigger chain is determined by the trigger enabled for the highest privilege level inside the chain. The entire trigger chain cannot be modified if the chain privilege level exceeds debug allowed privilege level.

[NOTE]
This represents a balance between usability and hardware complexity. There may be instances where the triggers are linked across different privilege levels (e.g., from S-mode to M-mode), while the external debugger may only have access with S-mode privilege. The external debugger should not modify the chain, because it could be suppressed or incorrectly match or fire in M-mode.

==== Sdtrig CSR

The CSRs tcontrol, scontext, hcontext, mcontext, and mscontext must follow access rules defined in <<dbgaccpriv, debug access privilege>>. Meanwhile, tselect, tdata1, tdata2, tdata3 are read/write when debug is allowed. The below table illustrates the accessibliby for Sdtrig CSRs.

[options="header"]
[cols="20%,20%,60%"]
.Trigger CSR accessibility in Debug Mode
|================================================================
| Register         | without Sdsec | with Sdsec                      
| tselect(0x7a0)   | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata1(0x7a1)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata2(0x7a2)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tdata3(0x7a3)    | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tinfo(0x7a4)     | Always     | mdbgen[i] == 1 \|\| sdedbgalw == 1
| tcontrol(0x7a5)  | Always     | access with <<dbgaccpriv, debug access privilege>> 
| scontext(0x5a8)  | Always     | access with <<dbgaccpriv, debug access privilege>>
| hcontext(0x6a8)  | Always     | access with <<dbgaccpriv, debug access privilege>>
| mcontext(0x7a8)  | Always     | access with <<dbgaccpriv, debug access privilege>>
| mscontext(0x7aa) | Always     | access with <<dbgaccpriv, debug access privilege>>    
|================================================================

Below fields in mcontrol, mcontrol6, icount, itrigger, etrigger, and tmexttrigger must follow the access rule specified in the table.
[options="header"]
[cols="20%,80%"]
.Tdata1 fields accessibility against privilege granted to external debugger
|====================================
| Field | Accessibility
| m     | mdbgen[i] == 1                           
| s     | mdbgen[i] == 1 \|\| sdedbgalw == 1    
| u     | mdbgen[i] == 1 \|\| sdedbgalw == 1   
| vs    | mdbgen[i] == 1 \|\| sdedbgalw == 1  
| vu    | mdbgen[i] == 1 \|\| sdedbgalw == 1
|====================================

The `intctl` and `sselect` fields in tmexttrigger are redifined as follows. 

[[redtmext]]
.Redefinition of field `intctl` and `sselect` within tmexttrigger
[options="header"]
[cols="10%,70%,10%,10%"]
|========================================================================================================================================================================================================================================================================
| Field  | Description                                                                                                                                                                                                                                 | Access  | Reset 
| intctl | This optional bit, when set, causes this trigger to fire whenever an attached interrupt controller signals a trigger.  the field is only configurable when mdbgen[i] is set to 1. | WLRL    | 0     
| sselect | Selects any combination of up to 16 Trigger Module external trigger inputs that cause this trigger to fire The legal value must be constrained by mdbgen[i] and `sdedbgalw` according to trigger input type.                                         | WLRL    | 0     
|========================================================================================================================================================================================================================================================================

=== Other CSR updates

==== Debug Control and Status (dcsr)

The dcsr is always accessible in Debug Mode. The access rules for field `prv` and `v` are addressed in subsection <<prvvacc>>. Beside `prv` and `v`, the accessiblity of remaining fields are listed in the following table.

.Dcsr fields accessibility against privilege granted to external debugger
[options="header"]
[cols="40%,60%"]
|============================================
| Field    |  Accessibility
| ebreakvs |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakvu |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreakm  |  mdbgen[i] == 1
| ebreaks  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| ebreaku  |  mdbgen[i] == 1 \|\| sdedbgalw == 1
| stepie   |  mdbgen[i] == 1
| stoptime |  mdbgen[i] == 1
| mprven   |  mdbgen[i] == 1
| nmip     |  mdbgen[i] == 1
|============================================

==== Debug PC (dpc) and Debug Scratch Register (dscratch0 and dscratch1)

Debug PC (at 0x7b1) and Debug Scratch Register (at 0x7b2 and 0x7b3) are not restricted by <<dbgaccpriv, debug access privilege>>, they are always accessible in Debug Mode.

[[Sdseccsr]]
==== Sdsec CSR

The Sdsec extension does not introduce any new CSR. The CSR control knobs in `msdcfg` for supervisor domain debug and trace are specified in Smsdedbg and Smsdetrc extension respectively in _RISC-V Supervisor Domains Access Protection_ cite:[smmtt]. The Smsdedbg and/or Smsdetrc extension must be implemented to support security control for debugging and/or tracing in supervisor domain.

